# Вопросы

### 1. Назовите основные принципы ООП. Расскажите подробно о каждом.
> * Абстракция
> Абстракция скрывает сложности реализации и предоставляет более простые интерфейсы.
> Если мы подумаем о типичном компьютере, то можно увидеть только внешний интерфейс, который наиболее важен для взаимодействия с ним, в то время как внутренние микросхемы и схемы скрыты от пользователя.
> В ООП абстракция означает сокрытие сложных деталей реализации программы, предоставляя доступ только к API, необходимому для использования реализации. В Java мы достигаем абстракции с помощью интерфейсов и абстрактных классов.
> * Инкапсуляция
> Инкапсуляция - это сокрытие состояния или внутреннего представления объекта от пользователя API и предоставление общедоступных методов, привязанных к объекту, для доступа на чтение-запись. Это позволяет скрывать определенную информацию и контролировать доступ к внутренней реализации.
> Например, поля-члены в классе скрыты от других классов, и к ним можно получить доступ с помощью методов-членов. Один из способов сделать это - сделать все поля данных закрытыми и доступными только с помощью общедоступных методов-членов:
> ```java
> public class Car {
>    // ...
>    private int speed;
>    public int getSpeed() {
>        return color;
>    }
>    public void setSpeed(int speed) {
>        this.speed = speed;
>    }
>    // ...
> }
> ```
> Здесь поле speed инкапсулируется с помощью модификатора private access, и к нему можно получить доступ только с помощью общедоступных методов getSpeed() и setSpeed() . Подробнее о модификаторах доступа мы можем прочитать в нашей статье "модификаторы доступа".
> * Наследование
> Наследование - это механизм, который позволяет одному классу приобретать все свойства другого класса путем наследования класса. Мы называем наследующий класс дочерним классом, а унаследованный класс - суперклассом или родительским классом.
> В Java мы делаем это путем расширения родительского класса. Таким образом, дочерний класс получает все свойства от родительского:
> ```java
> public class Car extends Vehicle {
> //...
> }
> ```
> Когда мы расширяем класс, мы формируем отношение "ЕСТЬ". Автомобиль -ЭТО транспортное средство. Таким образом, он обладает всеми характеристиками транспортного средства.
> * Полиморфизм
> Полиморфизм - это способность языка ООП обрабатывать данные по-разному в зависимости от типов входных данных. В Java это может быть одно и то же имя метода, имеющее разные сигнатуры метода и выполняющее разные функции:
> ```java
> public class TextFile extends GenericFile {
> //...
>    public String read() {
>        return this.getContent()
>          .toString();
>    }
> 
>    public String read(int limit) {
>        return this.getContent()
>          .toString()
>          .substring(0, limit);
>    }
> 
>    public String read(int start, int stop) {
>        return this.getContent()
>          .toString()
>          .substring(start, stop);
>    }
> }
> ```
> В этом примере мы можем видеть, что метод read() имеет три разные формы с разными функциональными возможностями. Этот тип полиморфизма является статическим или полиморфизмом во время компиляции и также называется перегрузкой метода.
> * https://www.baeldung.com/java-oop
### 2. Расскажите про иерархию наследования. Подробно про методы класса object.
> Ответ....

### 3. Что такое интерфейс, что такое абстрактный класс.
> В языке программирования Java интерфейс — это ссылочный тип, аналогичный классу, который может содержать только константы, сигнатуры методов, методы по умолчанию, статические методы и вложенные типы. Тела методов существуют только для методов по умолчанию и статических методов. Интерфейсы не могут быть созданы — они могут быть реализованы только классами или расширены другими интерфейсами.
> * https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html

> Абстрактный класс — это объявленный класс abstract, который может включать или не включать абстрактные методы. Абстрактные классы не могут быть созданы, но могут быть подклассами.
> * https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html

### 4. Может ли интерфейс \ абстрактный класс иметь конструктор, поля, статические статические \ дефолтные методы.
> Ответ....

### 5. Что такое Enum, в чем отличие от класса, может ли иметь методы, конструкторы, наследоваться реализовывать интерфейсы.
> Enum (перечисление) в Java — определяемый программистом тип данных, состоящий из множества предопределенных констант. Объявление enum подобно объявлению класса в java. Вместо ключевого слова class используется слово enum, тело перечисления должно начинаться с объявления констант через запятую. В соответствии с code convention, константы следует объявлять в верхнем регистре, отделяя слова нижним подчёркиванием (например, MONDAY или GREEN_COLOR) Кроме того, enum может содержать: методы; поля; приватный конструктор; блоки статической и нестатической инициализации; вложенные классы и интерфейсы; Для каждого элемента перечисления имеется возможность переопределять использованные методы. В частности, это позволяет объявить в теле перечисления абстрактный метод и переопределить его для каждого элемента. Каждое перечисление неявно наследует класс java.lang.Enum, поэтому не может наследоваться от другого класса. При этом допустима реализация интерфейсов. Унаследоваться от перечисления также нельзя. Класс Enum реализует интерфейсы Comparable и Serializable, а также предоставляет ряд методов для работы с перечислением, такие как name() — возвращает имя константы; ordinal() — очерёдность объявления данной константы в перечислении; Кроме того, к каждому enum-классу на стадии компиляции добавляются такие методы, как: статический valueOf(String name) — возвращает константу по её имени; статический values() — возвращает массив, содержащий все объявленные константы.
>* https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html
>* https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html
### 6. Расскажите про модификаторы доступа, к чему они применяются.
> Ответ....

### 7. Расскажите про конструкторы, с какими модификаторами они применяются, могут ли они наследоваться \ переопреляться?
> В Java для конструкторов могут применяться следующие модификаторы:
> * **public**  
>  Позволяет создавать экземпляры класса всюду без ограничений.
> * **private**  
>  Используется, если мы не хотим создавать объекты определенного класса извне, мы можем использовать закрытые или частные (private) конструкторы. Объявив конструкторы закрытыми, мы можем создавать объекты только внутри класса. Классы Singleton — хороший пример использования частных конструкторов.
> * **protected**  
>  Аналогичен модификатору private, позволяет запретить создание экземпляра базового класса, но в производных классах этот конструктор будет доступен, а стало быть, можно будет создавать потомков.
> * **default (если модификатор не указан)**  
>  Модификатор доступа конструктора по умолчанию всегда будет таким же, как модификатор класса. Если класс публичный, то конструктор тоже будет публичным. Если класс частный, то конструктор тоже будет частным. Аналогично будет и с другими модификаторами доступа.
>
> Могут ли конструкторы наследоваться \ переопреляться?  
> В Java конструкторы классов не могут наследоваться и не могут переопределяться.
> Однако, если класс наследует свойства другого класса, подкласс автоматически получает конструктор по умолчанию суперкласса. Но если вы хотите вызвать параметризованный конструктор суперкласса, вам нужно использовать ключевое слово super.  
> https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html

### 8. Можно ли в классе заимплементить 2 интерфейса? А если в них один и тот же метод doSmth? Как он реализуется?
> В java классе можно реализовать произвольное количество интерфейсов.
> При этом данный класс будет соответствовать типам всех тех интерфейсов, которые в нем реализованы.
> В примере ниже у двух интерфейсов есть абстрактный метод с одинаковой сигнатурой.
> При этом класс MyClass реализует оба этих интерфейса, и конфликтной ситуации не возникает.
>
> ```java
> public interface InterfaceA {
>     void doSomething();
> }
>
> public interface InterfaceB { 
>      void doSomething();
> }
> 
> public class MyClass implements InterfaceA, InterfaceB {
>     @Override
>     public void doSomething() {
>       System.out.println("реализация метода в классе MyClass");
>    }
> }
> ```
>
> Однако в Java 8  были добавлены Default-методы.
> В том случае если в двух интерфейсах будет Default-метод с одинаковой сигнатурой. Возникает ромбовидная проблема.
> Необходимо будет явно указать какой дефолтный метод будет унаследован, либо же реализовать метод самостоятельно.
>
> ```java
> public interface InterfaceA {
>     default void doSmth(){
>         System.out.println("InterfaceA");
>    }
> }
>
> public interface InterfaceB { 
>     default void doSmth(){
>         System.out.println("InterfaceB");
>     }
> }
> public class MyClass implements InterfaceA, InterfaceB {
>    @Override
>    public void doSmth() {
>        InterfaceA.super.doSmth();
>    }
>    /*
>    @Override
>    public void doSmth() {
>        InterfaceB.super.doSmth();
>    }
>    или же
>    
>    @Override
>    public void doSmth() {
>        System.out.println("MyClass");;
>    }
>    */
> }
> ```
>  Если же у методов названия одинаковые, но сигнатуры разные то ромбовидной проблемы не возникает.
> * https://docs.oracle.com/javase/tutorial/java/IandI/index.html

### 9. Статический \ динамический полиморфизм.
> Полиморфизм бывает статическим (Static Binding) и динамическим (Dynamic Binding). При статическом полиморфизме, он же раннее связывание, компилятор определяет, какой метод и где нужно вызвать. Это позволяет использовать такой механизм, как перегрузка. При динамическом полиморфизме, он же позднее связывание, по ранее вычисленной сигнатуре метода в рантайме будет вычислен метод на основе того, какой объект используется (т.е. метод какого объекта вызывается). То, как эти механизмы работают можно увидеть при помощи байткода.  
> <br/>
> Перегрузка смотрит на сигнатуры методов, а при разрешении перегрузки выбирается наиболее специфичный (наиболее точный) вариант. При переопределении смотрит на тип для определения, какие доступны методы, а сами методы вызываются на основе объекта.  
> * **Методы экземпляра (Dynamic Binding)**  
> Метод экземпляра в подклассе с той же сигнатурой (имя, плюс номер и тип его параметров) и возвращаемым типом, что и у метода экземпляра в суперклассе, переопределяет метод суперкласса.
> Способность подкласса переопределять метод позволяет классу наследовать от суперкласса, поведение которого "достаточно близко", а затем изменять поведение по мере необходимости. Переопределяющий метод имеет то же имя, количество и тип параметров, а также возвращаемый тип, что и метод, который он переопределяет. Переопределяющий метод также может возвращать подтип типа, возвращаемого переопределенным методом. Этот подтип называется ковариантным типом возвращаемого значения.
> При переопределении метода может потребоваться использовать @Override аннотацию, которая сообщает компилятору, что вы собираетесь переопределить метод в суперклассе. Если по какой-либо причине компилятор обнаружит, что метод не существует ни в одном из суперклассов, то он сгенерирует ошибку.  
<https://docs.oracle.com/javase/tutorial/java/IandI/override.html>  
> <br/>
> * **Методы перегрузки (Static Binding)**  
Язык программирования Java поддерживает методы с перегрузкой, и Java может различать методы с разными сигнатурами методов. Это означает, что методы внутри класса могут иметь одно и то же имя, если у них разные списки параметров.
Перегруженные методы различаются по количеству и типу аргументов, передаваемых в метод.
Вы не можете объявить более одного метода с одинаковым именем и одинаковым количеством и типом аргументов, потому что компилятор не может отличить их друг от друга.
Компилятор не учитывает тип возвращаемого значения при различении методов, поэтому вы не можете объявить два метода с одинаковой сигнатурой, даже если они имеют разный возвращаемый тип.
https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html



### 10. Что является членами класса.
> Ответ....

### 11. Расскажите подробно как переопределяются\ перегружаются методы классов наследников.
> Механизмы перегрузки и переопределения методов позволяют реализовать принцип полиформизма в Java.
> 
> Дочерний класс может переопределить методы экземпляра своего родительского класса. 
> Это называется переопределением метода. Метод экземпляра в подклассе с той же сигнатурой 
> (наименование, число и тип параметров) и типом возвращаемого значения, что и метод экземпляра в суперклассе, 
> переопределяет метод суперкласса. Таким образом, внешне метод экземпляра будет идентичен методу суперкласса, 
> но внутри метода может быть описана совершенно другая логика.
> Переопределяющий метод также может возвращать подтип типа, возвращаемого переопределенным методом. 
> Данный подтип называется ковариантным возвращаемым типом.
> 
> При переопределении метода обычно используют аннотацию @Override, которая сообщает компилятору, 
> что мы собираемся переопределить метод в суперклассе. Если по какой-то причине компилятор обнаружит, 
> что метод не существует ни в одном из суперклассов, то он выдаст ошибку.
> 
> Если сигнатура метода наследника будет отличаться от метода родителя, то есть например, если мы изменим 
> количество аргументов, тип/порядок аргументов или тип возвращаемого значения, 
> то это уже будет называться перегрузкой.
> Перегрузка характеризует ситуацию, когда "один и тот же" метод может работать с разными параметрами.
> С технической точки зрения это просто два разных метода, сигнатуры которых имеют одинаковое название,
> но разный набор параметров. Важно отметить, что если в классе объявлены два перегруженных метода,
> а аргумент в вызове подходит под оба, произойдет ошибка компиляции.
> 
> https://docs.oracle.com/javase/tutorial/java/IandI/override.html
> https://habr.com/ru/companies/otus/articles/347900/

### 12. Jvm, Jre, Jdk.
> Java Virtual Machine (JVM) — это реализация виртуальной машины, которая выполняет программу Java. Сначала JVM 
> интерпретирует байт-код. Затем он сохраняет информацию о классе в области памяти. Наконец, он выполняет байт-код, 
> сгенерированный компилятором Java.
> Java Runtime Environment (JRE) — это набор программных компонентов, используемых для запуска приложений Java.
> К компоненту JRE относится: реализация виртуальной машины Java (JVM).
> Java Development Kit (JDK) предоставляет среду и инструменты для разработки, компиляции, отладки и выполнения.
> К компоненту JDK относится: JRE.
> https://www.baeldung.com/jvm-vs-jre-vs-jdk

### 13. Расскажите что такое classpath java, общее правило именования пакетов java.
> Ответ....

### 14. Расскажите про интерфейсы Comparator, Comparable и их применение.
В интерфейсе Comparator объявлен метод compare (Object obj1, Object obj2), который позволяет сравнивать между собой два объекта. На выходе метод возвращает значение 0, если объекты равны, положительное значение или отрицательное значение, если объекты не тождественны.
Метод может вызвать исключение ClassCastException, если типы объектов не совместимы при сравнении.
https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Comparator.html

В интерфейсе Comparable объявлен только один метод compareTo (Object obj), предназначенный для упорядочивания объектов класса. Данный метод удобно использовать для сортировки списков или массивов объектов.
Метод compareTo (Object obj) сравнивает вызываемый объект с obj. В отличие от метода equals, который возвращает true или false, compareTo возвращает:
• 0, если значения равны;
• Отрицательное значение (обычно -1), если вызываемый объект меньше obj;
• Положительное значение (обычно +1), если вызываемый объект больше obj.
Если типы объектов не совместимы при сравнении, то compareTo (Object obj) может вызвать исключение ClassCastException. Необходимо помнить, что аргумент метода compareTo имеет тип сравниваемого объекта класса.
Обычные классы Byte, Short, Integer, Long, Double, Float, Character, String уже реализуют интерфейс Comparable.
https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Comparable.html

### 15. Расскажите про класс String, пул строк
> String это final класс объекты которого представляют собой строки(последовательность символов).
> Строки это неизменяемые объекты, это значит что при конкатенации или получении подстроки возвращается новый объект.
> StringPool - это область в Heap где хранятся строки. При создании строки с помощью "" проверяется есть ли такая строка
> в StringPool и если она там есть то возвращается ссылка на нее. Это помогает экономить память.
> При создании новой строки с помощью new можно поместить строку в пул или же получить ссылку на другой объект
> с таким же значением.  
> https://docs.oracle.com/javase/8/docs/api/java/lang/String.html

### 16. Расскажите про варианты использования зарезервированных слов таких как super, this, class, instace of.
> Ответ....

### 17. Java массивы, к какому типу относится, какие есть особенности можно ли создать 0 длинны, могут ли расширяться.
> В Java массивы являются упорядоченными коллекциями однородных элементов, имеющими фиксированный размер после создания. Они относятся к типу данных ссылочных (reference) типов, даже если содержат примитивные типы данных.

> Основные особенности массивов в Java:

> 1. Однородность: Все элементы массива должны быть одного и того же типа данных, будь то примитивные или ссылочные типы.

> 2. Фиксированный размер: После создания массива его размер остается неизменным. Нельзя добавлять или удалять элементы из массива, не создавая новый массив с другим размером.

> 3. Индексация: Элементы массива нумеруются начиная с индекса 0. Для доступа к элементу используется его индекс в квадратных скобках, например: array[0].

> 4. Длина массива: Длина массива определяется при его создании и остается постоянной. Доступ к длине массива можно получить через свойство length, например: array.length.

> Динамические массивы: Хотя размер обычных массивов фиксирован, в Java есть класс ArrayList, который представляет собой динамический массив, способный автоматически расширяться при добавлении элементов.

### 18. Назовите этапы создания \запуска блоков\конструкторов класса при наследовании.
> Существует 2 вида блоков инициализации:
> * **Нестатический (instance initializer)**  
> -> Используется для инициализации нестатических переменных(как правило).  
> -> Выполняется во время создания экземпляра класса.  
> -> Может использовать **статические** и **нестатические** поля класса.  
> -> Может использовать ключевое слово **this**  
> -> Выполняется каждый раз перед вызовом конструктора.  
> -> Компилятор копирует блок в каждый конструктор класса.
> ```java
> {
>   fieldName1 = fieldVal1;
>   fieldName2 = fieldVal2;
>   //other coder
> }
> ```
> * **Статический (class initializer)**  
> -> Используется для инициализации статических переменных.  
> -> Выполняется во время загрузки класса.  
> -> Может использовать только **статические** переменные.  
> -> **Не** может использовать ключевое слово **this**  
> -> Выполняется только один раз за запуск программы при загрузке класса в память.  
> -> Если их несколько в одном классе, то будут вызваны в том порядке, в котором находятся в коде.
> ```java
> static {
>   fieldName1 = fieldVal1;
>   fieldName2 = fieldVal2;
>   //other code
> }
> ```
> В конструкторе ребенка всегда неявно вызывается пустой конструктор родителя, если он есть. 
> Если его нет, то необходимо явно вызвать родительский конструктор, используя ключевое слово **super**  
> <br/>
> Таким образом, если создать классы родителя и ребенка, а затем запустить программу, то получим:  
> **Порядок выполнения:**
> 1. Статический блок родителя (загрузка класса в память)
> 2. Статический блок ребенка (загрузка класса в память)
> 3. Нестатический блок родителя (пытаемся создать экземпляр ребенка)
> 4. Конструктор родителя
> 5. Нестатический блок ребенка
> 6. Конструктор ребенка  
> * https://www.baeldung.com/java-static-instance-initializer-blocks  
> * https://docs.oracle.com/javase/tutorial/java/javaOO/initial.html
> * https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html

### 19. Расскажите какое будет поведение если внутри цикла вызвать оператор break\continue.
Используя break, вы можете форсировать немедленное завершение цикла, обходя условное выражение и любой остающийся код в теле цикла. Когда оператор break встречается внутри цикла, второй заканчивается и программное управление передается оператору, следующему за ним. 
Замечание: Break не проектировался в качестве нормального средства завершения цикла. Эту цель обслуживает условное выражение заголовка цикла. Оператор break следует использовать для прерывания цикла только тогда, когда возникают некоторые специальные ситуации.

Использование оператора continue
Иногда полезно начать очередную итерацию цикла пораньше. То есть нужно продолжить выполнение цикла, но прекратить обработку остатка кода в его теле для данной частной итерации. Такое действие выполняет оператор continue. В циклах while и do while оператор continue вызывает передачу управления непосредственно условному выражению, которое управляет циклом. В цикле for управление переходит сначала к итерационной части оператора for и затем к условному выражению. Для всех трех циклов любой промежуточный код обходится.

### 20. Что такое Generic?
> Ответ....

### 21. Расскажите про такое зарезервированное слово как final, к чему применяется как используется.
> Ключевое слово `final` в Java используется для обозначения, что сущность (переменная, метод или класс) не может быть изменена или расширена после своего первоначального определения.

> 1. **Для переменных:** Если переменная объявлена как `final`, ей можно присвоить значение только один раз. Попытка изменения значения переменной после инициализации приведет к ошибке компиляции.

> 2. **Для методов:** Если метод объявлен как `final`, его нельзя переопределить в классах-потомках. 

> 3. **Для классов:** Если класс объявлен как `final`, он не может быть наследован. Такой класс считается окончательной реализацией, и другие классы не могут расширять его функциональность путем наследования.

> [The Java™ Tutorials - The final Keyword](https://docs.oracle.com/javase/tutorial/java/IandI/final.html)

### 22. Рассказать про Optional.
> Optional - это своего рода контейнер, в котором может лежать значение, а может и не лежать. 
> Если в нем лежит значение — это означает, что оно присутствует в контейнере. По-английски это переводится present. 
> Если значения в контейнере нет — контейнер пуст, или empty. Поэтому проверяя, есть ли значение в optional, 
> мы пишем ifPresent (если присутствует) или isPresent (присутствует) и делаем какие-то действия. Если значение есть, 
> мы можем его из Optional получить через метод get().
> 
> Одно из многих преимуществ — мы можем устанавливать значения по умолчанию с помощью метода orElse().
> 
> Когда мы видим Optional в коде, мы понимаем, что здесь значения может и не быть, и чтобы избежать ошибок, мы уже 
> будем знать, что нам нужно обработать ситуации, когда значения в контейнере нет — выбросить ошибку (orElseThrow()) 
> или получить значение по умолчанию (есть два метода orElse() и orElseGet(), первый создает объект, при отсутствии 
> значения, который нам может быть и не нужен, а второй принимает функциональный интерфейс и возвращает результат его 
> метода).
> 
> https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Optional.html
> https://www.baeldung.com/java-optional